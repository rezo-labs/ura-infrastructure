// -----------------------------------------------------
// My customize plugin, original plugin from https://github.com/1337programming/webpack-shell-plugin
// -----------------------------------------------------
const cp = require('child_process');

class WebpackShellPlugin {
    /**
    * @callback AfterFirstEmit
    * @param  {cp.ChildProcess} proc - The process of the Node.js script.
    */
    /**
     * @param {Object} configs - Configuration object
     * @param {String} configs.path - The path of the Node.js script to be executed
     * @param {AfterFirstEmit} configs.afterFirstEmit - called after the first emit of Webpack,
     *  when the Node.js process has just been started.
     * @param {Boolean} ssr - Indicate Server-side rendering mode. If true, changes in client code
     *  will cause restart of the Node process just like server code. Otherwise, only changes in
     *  server code can. It makes sure that the markup generated by the SSR server will always match
     *  the client expectation, but it causes .
     */
    constructor({ path, afterFirstEmit, ssr }) {
        this.configs = {
            path,
            afterFirstEmit,
            ssr,
        };

        this.reg = this.configs.ssr
            ? /(src\/(client|server)\/.*)/
            : /(src\/(server)\/.*)/;
        this.afterFirstEmitCalled = false;
    }

    /**
     * Check if there are changes in the server source code.
     * @param {String[]} changedFiles - The list of changed files detected by Webpack.
     * @param {Boolean} [log=false] - Enable logging of changed files.
     */
    checkIfChanged(changedFiles, log = false) {
        // Check if some of these changed files are from source code
        const filteredChangedFiles = changedFiles.filter(e => e.match(this.reg));
        if (log) {
            if (filteredChangedFiles.length > 0) {
                console.log('Changed files: ', filteredChangedFiles);
            }
        }
        return (filteredChangedFiles.length > 0);
    }

    apply(compiler) {
        compiler.hooks.compilation.tap('CompilationPlugin', (compilation) => {
            if (this.proc && !this.proc.killed) {
                const changedFiles = Object.keys(
                    compilation.compiler.watchFileSystem.watcher.mtimes,
                );
                if (this.checkIfChanged(changedFiles, true)) {
                    this.proc.kill('SIGINT');
                }
            }
        });

        compiler.hooks.shouldEmit.tap('ShouldEmitPlugin', (compilation) => {
            const changedFiles = Object.keys(
                compilation.compiler.watchFileSystem.watcher.mtimes,
            );
            if (this.proc && !this.proc.killed) {
                return this.checkIfChanged(changedFiles);
            }
            return true;
        });

        compiler.hooks.afterEmit.tap('AfterEmitPlugin', (compilation) => {
            if (compilation.errors.length === 0) {
                this.proc = cp.fork(this.configs.path, [], { stdio: 'inherit' });
                this.proc.on('close', () => {
                    console.log('Node process terminated');
                });
                if (!this.afterFirstEmitCalled) {
                    this.afterFirstEmitCalled = true;
                    this.configs.afterFirstEmit(this.proc);
                }
            }
        });

        compiler.hooks.watchClose.tap('WatchClosePlugin', () => {
            if (this.proc && !this.proc.killed) {
                this.proc.kill('SIGINT');
            }
        });
    }
}

module.exports = WebpackShellPlugin;
